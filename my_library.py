# -*- coding: utf-8 -*-
"""Kopia LSTM_1_close_R.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Di_oT-sA5RIxx_SVpXtEmtK84TDiOU9z

https://adriangb.com/scikeras/stable/notebooks/Basic_Usage.html#7.-Usage-with-sklearn-GridSearchCV
"""

# import tensorflow as tf
# device_name = tf.test.gpu_device_name()
# if device_name != '/device:GPU:0':
#   raise SystemError('GPU device not found')
# print('Found GPU at: {}'.format(device_name))

# try:
#     import yfinance as yf
# except:
#     !pip install yfinance
#     import yfinance as yf
#
# try:
#     import pandas_ta as ta
# except:
#     !pip install pandas_ta
#     import pandas_ta as ta
#
# ! pip install scikeras
#
# !pip install keras-tuner --upgrade

"""# Libraries"""
import yfinance as yf
import pandas_ta as ta
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
#import seaborn as sns
from sklearn.preprocessing import MinMaxScaler, StandardScaler

import tensorflow as tf
from tensorflow import keras
from sklearn.model_selection import train_test_split
from kerastuner import HyperModel, BayesianOptimization, Tuner, HyperParameters
from kerastuner.tuners import RandomSearch
from kerastuner.engine.hyperparameters import HyperParameters

import keras_tuner
from keras.models import Sequential
from keras.layers import Dense, Dropout, SimpleRNN, LSTM, GRU, BatchNormalization, Bidirectional, Input, Reshape, TimeDistributed
from keras.losses import MeanSquaredError
from keras.metrics import RootMeanSquaredError
from keras.optimizers import Adam

from keras.callbacks import EarlyStopping
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error, mean_absolute_percentage_error
from sklearn.linear_model import LinearRegression, ElasticNet

plt.rcParams["figure.figsize"] = (18, 4)
plt.rcParams["font.size"] = '13'

"""# Data loading"""

def train_valid_test(data, name, test=0.1, val=0.1):
    dates = data.index
    y = data['Close']
    for_test = int(len(data) * test)
    for_val = int(len(data) * val)
    to_train = len(data) - for_test - for_val
    y_train, y_val, y_test = y[:to_train], y[to_train:to_train+for_val], y[to_train+for_val:] 
    dates_train, dates_val, dates_test = dates[:to_train], dates[to_train:to_train+for_val], dates[to_train+for_val:]
    print(len(data))
    print(len(y_train))
    print(len(y_val))
    print(len(y_test))
    plt.plot(dates_train, y_train, label='Trainining set')
    plt.plot(dates_val, y_val,  label='Validation set')
    plt.plot(dates_test, y_test, label='Testing set')
    plt.title(f'{name} closing price')
    plt.xlabel('Date')
    plt.ylabel('Close price')
    plt.legend()
    plt.show()

data = yf.download(tickers='ORAN', start='2015-01-01', end='2023-01-01') #NYSE - Nasdaq Real Time Price
train_valid_test(data, 'ORANGE', test=0.1, val=0.1)

data2 = yf.download(tickers='SBUX', start='2015-01-01', end='2023-01-01') #NasdaqGS
train_valid_test(data2, 'STARBUCKS CORPORATION', test=0.1, val=0.1)

data3 = yf.download(tickers='ACP.WA', start='2015-01-01', end='2023-01-01') #Warsaw
train_valid_test(data3, 'ASSECO POLAND', test=0.1, val=0.1)

data4 = yf.download(tickers='PFE', start='2015-01-01', end='2023-01-01') #NYSE
train_valid_test(data4, 'PFIZER', test=0.1, val=0.1)

"""# Functions"""

class StockFeatures:
    def __init__(self, data):
        # data: DataFrame
        self.data = data
        self.new_data = pd.DataFrame()
        self.columns = self.data.columns.values
        self.target_name = None
        self.X = None
        self.y = None
        self.dates = None

    def choose_columns(self, names):
        # names: list of strings
        for name in names:
            if name not in self.columns:
                raise ValueError(f"No '{name}' in the dataframe")
            else:
                self.new_data[name] = self.data[name]

    def choose_columns_pct(self, names):
        # names: list of strings
        for name in names:
            if name not in self.columns:
                raise ValueError(f"No '{name}' in the dataframe")
            else:
                self.new_data[f"{name}_pct"] = self.data[name].pct_change()
                self.new_data.dropna(inplace=True)

    def add_MA(self, name, p):
        if name not in self.columns:
            raise ValueError(f"No '{name}' in the dataframe")
        else:
            self.new_data[f"MA_{name}_{p}"] = ta.ema(self.data[name], length=p)

    def add_MA_pct(self, name, p):
        if name not in self.columns:
            raise ValueError(f"No '{name}' in the dataframe")
        else:
            self.new_data[f"MA_{name}_{p}_pct"] = ta.ema(self.data[name], length=p).pct_change()

    def add_target_price(self, name):
        # Shifted price by one
        # name: column name to be shifted
        self.target_name = f"{name} target"
        if name not in self.columns:
            raise ValueError(f"No '{name}' in the dataframe")
        else:
            self.new_data[self.target_name] = self.data[name].shift(-1)
            self.new_data.dropna(inplace=True)

    def add_target_price_pct(self, name):
        self.target_name = f"{name} target pct"
        if name not in self.columns:
            raise ValueError(f"No '{name}' in the dataframe")
        else:
            self.new_data[self.target_name] = self.new_data[f"{name}_pct"].shift(-1)
            self.new_data.dropna(inplace=True)

    def X_days_back(self, days):
        # Creates inputs.
        # days: int, number of days to be in one sample
        self.X = []
        data_np_X = np.array(self.new_data.drop(columns=self.target_name))
        data_np_y = np.array(self.new_data[self.target_name])
        for i in range(len(self.new_data.drop(columns=self.target_name).columns)):
            self.X.append([])
            for j in range(days, data_np_X.shape[0]+1):
                self.X[i].append(data_np_X[j-days:j, i])
        self.X = np.moveaxis(self.X, [0], [2])
        self.X = np.array(self.X)
        y_help = np.array(data_np_y[days-1:])
        self.y = np.reshape(y_help, (len(y_help),1))
        self.dates = self.new_data.index[-len(self.y):]

    def train_valid_test(self, test=0.1, val=0.1):
        # Splits data into train, valid and test sets
        for_test = int(len(self.data) * test)
        for_val = int(len(self.data) * val)
        to_train = len(self.X) - for_test - for_val
        self.X_train, self.X_val, self.X_test = self.X[:to_train], self.X[to_train:to_train+for_val], self.X[to_train+for_val:]
        self.y_train, self.y_val, self.y_test = self.y[:to_train], self.y[to_train:to_train+for_val], self.y[to_train+for_val:]
        self.dates_train, self.dates_val, self.dates_test = self.dates[:to_train], self.dates[to_train:to_train+for_val], self.dates[to_train+for_val:]

    def min_max_scale_X(self):
        sc = MinMaxScaler()
        self.X_train = sc.fit_transform(self.X_train.reshape(-1, self.X_train.shape[-1])).reshape(self.X_train.shape)
        self.X_val = sc.transform(self.X_val.reshape(-1, self.X_val.shape[-1])).reshape(self.X_val.shape)
        self.X_test = sc.transform(self.X_test.reshape(-1, self.X_test.shape[-1])).reshape(self.X_test.shape)

    def std_scale_X(self):
        sc = StandardScaler()
        self.X_train = sc.fit_transform(self.X_train.reshape(-1, self.X_train.shape[-1])).reshape(self.X_train.shape)
        self.X_val = sc.transform(self.X_val.reshape(-1, self.X_val.shape[-1])).reshape(self.X_val.shape)
        self.X_test = sc.transform(self.X_test.reshape(-1, self.X_test.shape[-1])).reshape(self.X_test.shape)

    def std_scale(self):
        self.scaler = StandardScaler()
        self.X_train = self.scaler.fit_transform(self.X_train.reshape(-1, self.X_train.shape[-1])).reshape(self.X_train.shape)
        self.X_val = self.scaler.transform(self.X_val.reshape(-1, self.X_val.shape[-1])).reshape(self.X_val.shape)
        self.X_test = self.scaler.transform(self.X_test.reshape(-1, self.X_test.shape[-1])).reshape(self.X_test.shape)
        self.scaler_y = StandardScaler()
        self.y_train = self.scaler_y.fit_transform(self.y_train)
        self.y_val = self.scaler_y.transform(self.y_val)
        self.y_test = self.scaler_y.transform(self.y_test)

"""# Window 30"""

def transform_return_all(data, stock_obj, y_train_pred, y_val_pred, y_test_pred, days):
    pred_pct = np.concatenate((y_train_pred, y_val_pred, y_test_pred)).reshape(-1,)
    days = len(data) - len(pred_pct) - 1
    true_close = stock_obj.data['Close'].iloc[-2-len(pred_pct):-2].values
    new_pred = pred_pct * true_close + true_close

    y_train = stock_obj.data['Close'].iloc[days:-1].values[:len(stock_obj.dates_train)]
    y_train_pred = new_pred[:len(stock_obj.dates_train)]

    y_val = stock_obj.data['Close'].iloc[days:-1].values[len(stock_obj.dates_train):len(stock_obj.dates_train)+len(stock_obj.dates_val)]
    y_val_pred = new_pred[len(stock_obj.dates_train):len(stock_obj.dates_train)+len(stock_obj.dates_val)]

    y_test = stock_obj.data['Close'].iloc[days:-1].values[len(stock_obj.dates_train)+len(stock_obj.dates_val):]
    y_test_pred = new_pred[len(stock_obj.dates_train)+len(stock_obj.dates_val):]

    return y_train, y_train_pred, y_val, y_val_pred, y_test, y_test_pred

def return_stock_obj(data, window_size, features):
    stock_obj = StockFeatures(data)
    stock_obj.choose_columns_pct(['Close'])
    if features > 1:
        stock_obj.choose_columns_pct(['Volume'])
    if features > 2:
        stock_obj.choose_columns_pct(['Open'])
        stock_obj.choose_columns_pct(['High'])
        stock_obj.choose_columns_pct(['Low'])
    if features > 5:
        stock_obj.add_MA_pct('Close', 5)
        stock_obj.add_MA_pct('Close', 10)
        stock_obj.add_MA_pct('Close', 15)
    stock_obj.add_target_price_pct('Close')
    stock_obj.X_days_back(window_size)
    stock_obj.train_valid_test(test=0.1, val=0.1)
    stock_obj.std_scale()
    return stock_obj

def prepare_data_test(data, window_size, features):
    stock_obj = return_stock_obj(data, window_size, features)
    X_train = stock_obj.X_train
    X_val = stock_obj.X_val
    X_test = stock_obj.X_test
    y_train = stock_obj.y_train
    y_val = stock_obj.y_val
    y_test = stock_obj.y_test
    return stock_obj, X_train, y_train, X_val, y_val, X_test, y_test

def prepare_data(hp, data, window_size, features):
    stock_obj = return_stock_obj(data, window_size, features)
    X_train = stock_obj.X_train
    X_val = stock_obj.X_val
    y_train = stock_obj.y_train
    y_val = stock_obj.y_val
    return X_train, y_train, X_val, y_val

def mov(y_true, y_pred):
      vect = ((y_true[1:] - y_true[:-1] > 0).astype(int) == (y_pred[1:] - y_true[:-1] > 0).astype(int)).astype(int)
      correct = np.sum(vect)
      return correct/len(vect)

def plot_results(y, y_pred, dates, name, price='price'):
    add_str = ''
    if price == 'price':
        add_str = f', mov = {mov(y, y_pred):.4f}'
    plt.plot(dates, y, 'k')
    mse = mean_squared_error(y, y_pred)
    plt.plot(dates, y_pred, '-o',
             label=f'Pred {name}, MSE = {mse:.4f}{add_str}',
             markersize=3)
    plt.title(f'Stock closing {price}: true vs predicted')
    plt.xlabel('Date')
    plt.ylabel('Close price')
    plt.legend()

def best_model_check(data, tuner, best_model, window_size, features):
    print(tuner.search_space_summary())
    print('\nBest model hyperparameters:')
    print(tuner.results_summary(num_trials=1))
    stock_obj, X_train, y_train, X_val, y_val, X_test, y_test = prepare_data_test(data, window_size, features)
    test_loss, test_mse = best_model.evaluate(X_test, y_test)
    print('\nTest loss:', test_loss)
    print('Test MSE:', test_mse)

    pred_train = best_model.predict(X_train)
    pred_val = best_model.predict(X_val)
    pred_test = best_model.predict(X_test)

    plot_results(y_train, pred_train, stock_obj.dates_train, 'train', price='returns')
    plot_results(y_val, pred_val, stock_obj.dates_val, 'val', price='returns')
    plot_results(y_test, pred_test, stock_obj.dates_test, 'test', price='returns')
    plt.show()
    plt.figure(figsize=(12, 5))
    plt.plot(stock_obj.dates_test, y_test, '-o', color='k', label='True', markersize=4)
    plt.plot(stock_obj.dates_test, pred_test, '-o', color='tab:green', label='Predicted', markersize=4)
    plt.xlabel('Date')
    plt.ylabel('Close price')
    plt.title('Stock closing returns: true vs predicted')
    plt.legend()
    plt.show()

    pred_train = stock_obj.scaler_y.inverse_transform(pred_train)
    pred_val = stock_obj.scaler_y.inverse_transform(pred_val)
    pred_test = stock_obj.scaler_y.inverse_transform(pred_test)

    y_train, pred_train, y_val, pred_val, y_test, pred_test = transform_return_all(data, stock_obj, pred_train, pred_val, pred_test, window_size)

    plot_results(y_train, pred_train, stock_obj.dates_train, 'train')
    plot_results(y_val, pred_val, stock_obj.dates_val, 'val')
    plot_results(y_test, pred_test, stock_obj.dates_test, 'test')
    plt.show()
    plt.figure(figsize=(12, 5))
    plt.plot(stock_obj.dates_test, y_test, '-o', color='k', label='True', markersize=4)
    plt.plot(stock_obj.dates_test, pred_test, '-o', color='tab:green', label='Predicted', markersize=4)
    plt.xlabel('Date')
    plt.ylabel('Close price')
    plt.title('Stock closing price: true vs predicted')
    plt.legend()
    plt.show()


